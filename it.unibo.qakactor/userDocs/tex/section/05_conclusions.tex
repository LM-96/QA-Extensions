\section{Conclusions}

By summarizing, we started our work by \textbf{defining} passive entities that only describe all the components of an actor based system (in terms of contexts, actors, states and transitions).
After, we said that we used the \textit{builder pattern} in order to create these entities. Then, the builders can be used from others component in order to load the system with a certain mechanism and after wrap them into \texttt{ActorBasic} instances thanks to some \textit{wrappers}.
The mechanism we have presented is based on \textbf{annotations}, and we have shown all those available.

Now, the application designer can use three ways to define his own actor system:
\begin{enumerate}
	\item \textbf{using only the \textit{descriptive annotations}} with the legacy \texttt{ActorBasic} and \texttt{ActorBasicFsm} classes [\href{https://github.com/LM-96/QA-Extensions/tree/main/it.unibo.ledsonardemo0}{\textcolor{Emerald}{\textbf{ledonarsystem0}}}]
	
	\item \textbf{using only the \textit{descriptive annotations}} with the new \texttt{AutoQActorBasic} and \texttt{AutoQActorBasicFsm} classes that let to use the empty constructor [\href{https://github.com/LM-96/QA-Extensions/tree/main/it.unibo.ledsonardemo1}{\textcolor{Emerald}{\textbf{ledonarsystem1}}}]
	
	\item \textbf{using the full annotation support (\textit{descriptive} and \textit{behavioural})} with the new \texttt{QActorBasic} and \texttt{QActorBasicFsm} classes [\href{https://github.com/LM-96/QA-Extensions/tree/main/it.unibo.ledsonardemo2}{\textcolor{Emerald}{\textbf{ledonarsystem2}}}]
\end{enumerate}

Surely, the third mechanism is the most effective and practical with the smartest code even if it has not the same \textit{language support} of the original \texttt{DSL}. However, it has the great advantage \textbf{to be completely independent of any IDE} or third-party tools because the annotations are directly supported from \texttt{Java} and \texttt{Kotlin}.




